"use strict";(globalThis.webpackChunkros2_book=globalThis.webpackChunkros2_book||[]).push([[622],{8453(n,e,a){a.d(e,{R:()=>i,x:()=>c});var t=a(6540);const o={},r=t.createContext(o);function i(n){const e=t.useContext(r);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function c(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:i(n.components),t.createElement(r.Provider,{value:e},n.children)}},9275(n,e,a){a.r(e),a.d(e,{assets:()=>m,contentTitle:()=>c,default:()=>p,frontMatter:()=>i,metadata:()=>t,toc:()=>s});const t=JSON.parse('{"id":"vla/voice-command-mapping","title":"Voice Command Mapping Guide","description":"Overview","source":"@site/docs/vla/voice-command-mapping.md","sourceDirName":"vla","slug":"/vla/voice-command-mapping","permalink":"/docs/vla/voice-command-mapping","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/vla/voice-command-mapping.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"OpenAI Whisper Integration Guide","permalink":"/docs/vla/whisper-integration"},"next":{"title":"Latency and Accuracy Considerations in Voice-to-Action Systems","permalink":"/docs/vla/latency-accuracy"}}');var o=a(4848),r=a(8453);const i={},c="Voice Command Mapping Guide",m={},s=[{value:"Overview",id:"overview",level:2},{value:"Understanding Command Mapping",id:"understanding-command-mapping",level:2},{value:"Basic Command Mapping Architecture",id:"basic-command-mapping-architecture",level:2},{value:"Simple Command Mapping",id:"simple-command-mapping",level:2},{value:"1. Static Command Mapping",id:"1-static-command-mapping",level:3},{value:"2. Fuzzy Command Matching",id:"2-fuzzy-command-matching",level:3},{value:"Advanced Command Mapping with Parameters",id:"advanced-command-mapping-with-parameters",level:2},{value:"1. Parameter Extraction",id:"1-parameter-extraction",level:3},{value:"2. Context-Aware Command Mapping",id:"2-context-aware-command-mapping",level:3},{value:"Integration with LLMs for Complex Mapping",id:"integration-with-llms-for-complex-mapping",level:2},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"1. Caching Mapped Commands",id:"1-caching-mapped-commands",level:3},{value:"2. Confidence Scoring",id:"2-confidence-scoring",level:3},{value:"Testing Command Mapping",id:"testing-command-mapping",level:2},{value:"1. Unit Tests",id:"1-unit-tests",level:3},{value:"2. Integration Tests",id:"2-integration-tests",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Troubleshooting Common Issues",id:"troubleshooting-common-issues",level:2},{value:"1. Command Not Recognized",id:"1-command-not-recognized",level:3},{value:"2. Incorrect Parameter Extraction",id:"2-incorrect-parameter-extraction",level:3},{value:"3. High False Positives",id:"3-high-false-positives",level:3},{value:"Next Steps",id:"next-steps",level:2}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.header,{children:(0,o.jsx)(e.h1,{id:"voice-command-mapping-guide",children:"Voice Command Mapping Guide"})}),"\n",(0,o.jsx)(e.h2,{id:"overview",children:"Overview"}),"\n",(0,o.jsx)(e.p,{children:"This guide covers how to map natural language voice commands to specific robot actions. Effective command mapping is crucial for creating intuitive human-robot interactions where spoken commands reliably translate to robot behaviors."}),"\n",(0,o.jsx)(e.h2,{id:"understanding-command-mapping",children:"Understanding Command Mapping"}),"\n",(0,o.jsx)(e.p,{children:"Command mapping is the process of converting recognized speech (text) into executable robot actions. This involves:"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Natural Language Understanding"}),": Parsing the intent from spoken commands"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Action Mapping"}),": Converting intents to specific robot commands"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Parameter Extraction"}),": Identifying parameters like distances, objects, or locations"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Action Execution"}),": Executing the mapped robot action"]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"basic-command-mapping-architecture",children:"Basic Command Mapping Architecture"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:"Voice Command \u2192 Intent Recognition \u2192 Parameter Extraction \u2192 Action Mapping \u2192 Robot Execution\n"})}),"\n",(0,o.jsx)(e.h2,{id:"simple-command-mapping",children:"Simple Command Mapping"}),"\n",(0,o.jsx)(e.h3,{id:"1-static-command-mapping",children:"1. Static Command Mapping"}),"\n",(0,o.jsx)(e.p,{children:"The simplest approach is to create a static mapping between voice commands and robot actions:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'class StaticCommandMapper:\n    def __init__(self):\n        self.command_map = {\n            # Navigation commands\n            "move forward": {\n                "action": "navigation/move_forward",\n                "parameters": {"distance": 1.0}\n            },\n            "move backward": {\n                "action": "navigation/move_backward",\n                "parameters": {"distance": 1.0}\n            },\n            "turn left": {\n                "action": "navigation/turn",\n                "parameters": {"angle": -90}\n            },\n            "turn right": {\n                "action": "navigation/turn",\n                "parameters": {"angle": 90}\n            },\n            "stop": {\n                "action": "control/stop",\n                "parameters": {}\n            },\n\n            # Manipulation commands\n            "pick up object": {\n                "action": "manipulation/pick_object",\n                "parameters": {}\n            },\n            "place object": {\n                "action": "manipulation/place_object",\n                "parameters": {}\n            },\n\n            # System commands\n            "power off": {\n                "action": "system/power_off",\n                "parameters": {}\n            },\n            "power on": {\n                "action": "system/power_on",\n                "parameters": {}\n            }\n        }\n\n    def map_command(self, command_text):\n        """Map command text to robot action"""\n        command_lower = command_text.lower().strip()\n\n        # Exact match\n        if command_lower in self.command_map:\n            return self.command_map[command_lower]\n\n        # Partial match\n        for key, value in self.command_map.items():\n            if key in command_lower:\n                return value\n\n        return {\n            "action": "unknown/command",\n            "parameters": {"text": command_text}\n        }\n'})}),"\n",(0,o.jsx)(e.h3,{id:"2-fuzzy-command-matching",children:"2. Fuzzy Command Matching"}),"\n",(0,o.jsx)(e.p,{children:"For more robust command recognition, implement fuzzy matching:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'import difflib\n\nclass FuzzyCommandMapper:\n    def __init__(self, threshold=0.7):\n        self.threshold = threshold\n        self.commands = [\n            "move forward", "move backward", "turn left", "turn right",\n            "stop", "pick up object", "place object", "power off", "power on"\n        ]\n\n        # Extended command variations\n        self.command_variations = {\n            "move forward": ["move forward", "go forward", "move ahead", "go ahead", "forward"],\n            "move backward": ["move backward", "go backward", "move back", "go back", "backward", "back"],\n            "turn left": ["turn left", "turn to the left", "left turn", "turn left", "left"],\n            "turn right": ["turn right", "turn to the right", "right turn", "turn right", "right"],\n            "stop": ["stop", "halt", "freeze", "pause"],\n            "pick up object": ["pick up object", "pick up", "grasp", "grab", "take object"],\n            "place object": ["place object", "place", "put down", "release", "drop"],\n        }\n\n    def map_command(self, command_text):\n        """Map command with fuzzy matching"""\n        command_lower = command_text.lower().strip()\n\n        # Check for exact matches first\n        for canonical_command, variations in self.command_variations.items():\n            if command_lower in variations:\n                # Return the canonical command structure\n                return self._get_command_structure(canonical_command)\n\n        # Fuzzy matching\n        best_matches = difflib.get_close_matches(\n            command_lower,\n            [cmd for variations in self.command_variations.values() for cmd in variations],\n            n=1,\n            cutoff=self.threshold\n        )\n\n        if best_matches:\n            # Find the canonical command for the matched variation\n            matched_variation = best_matches[0]\n            for canonical_command, variations in self.command_variations.items():\n                if matched_variation in variations:\n                    return self._get_command_structure(canonical_command)\n\n        return {\n            "action": "unknown/command",\n            "parameters": {"text": command_text, "confidence": 0.0}\n        }\n\n    def _get_command_structure(self, canonical_command):\n        """Get the action structure for a canonical command"""\n        base_map = {\n            "move forward": {\n                "action": "navigation/move_forward",\n                "parameters": {"distance": 1.0}\n            },\n            "move backward": {\n                "action": "navigation/move_backward",\n                "parameters": {"distance": 1.0}\n            },\n            "turn left": {\n                "action": "navigation/turn",\n                "parameters": {"angle": -90}\n            },\n            "turn right": {\n                "action": "navigation/turn",\n                "parameters": {"angle": 90}\n            },\n            "stop": {\n                "action": "control/stop",\n                "parameters": {}\n            },\n            "pick up object": {\n                "action": "manipulation/pick_object",\n                "parameters": {}\n            },\n            "place object": {\n                "action": "manipulation/place_object",\n                "parameters": {}\n            }\n        }\n        return base_map.get(canonical_command, {\n            "action": "unknown/command",\n            "parameters": {"text": canonical_command}\n        })\n'})}),"\n",(0,o.jsx)(e.h2,{id:"advanced-command-mapping-with-parameters",children:"Advanced Command Mapping with Parameters"}),"\n",(0,o.jsx)(e.h3,{id:"1-parameter-extraction",children:"1. Parameter Extraction"}),"\n",(0,o.jsx)(e.p,{children:"Many commands require parameters like distances, angles, or object names:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'import re\n\nclass ParameterizedCommandMapper:\n    def __init__(self):\n        self.patterns = {\n            # Navigation with distance\n            "move_forward_distance": {\n                "pattern": r"move forward (\\d+(?:\\.\\d+)?) meters?",\n                "action": "navigation/move_forward",\n                "param_extractor": lambda match: {"distance": float(match.group(1))}\n            },\n            "move_backward_distance": {\n                "pattern": r"move backward (\\d+(?:\\.\\d+)?) meters?",\n                "action": "navigation/move_backward",\n                "param_extractor": lambda match: {"distance": float(match.group(1))}\n            },\n            "turn_angle": {\n                "pattern": r"turn (left|right) (\\d+(?:\\.\\d+)?) degrees?",\n                "action": "navigation/turn",\n                "param_extractor": lambda match: {\n                    "angle": float(match.group(2)) if match.group(1) == "right" else -float(match.group(2))\n                }\n            },\n            # Object manipulation\n            "pick_object": {\n                "pattern": r"pick up (?:the )?(\\w+)",\n                "action": "manipulation/pick_object",\n                "param_extractor": lambda match: {"object_type": match.group(1)}\n            },\n            "place_object_at": {\n                "pattern": r"place (?:the )?(\\w+) at (\\w+)",\n                "action": "manipulation/place_object",\n                "param_extractor": lambda match: {\n                    "object_type": match.group(1),\n                    "destination": match.group(2)\n                }\n            }\n        }\n\n    def map_command(self, command_text):\n        """Map command with parameter extraction"""\n        command_lower = command_text.lower().strip()\n\n        for pattern_name, pattern_config in self.patterns.items():\n            match = re.search(pattern_config["pattern"], command_lower)\n            if match:\n                try:\n                    params = pattern_config["param_extractor"](match)\n                    return {\n                        "action": pattern_config["action"],\n                        "parameters": params\n                    }\n                except Exception as e:\n                    print(f"Error extracting parameters: {e}")\n                    continue\n\n        # Fall back to simple mapping\n        return self._simple_map(command_text)\n\n    def _simple_map(self, command_text):\n        """Simple command mapping as fallback"""\n        simple_map = {\n            "move forward": {"action": "navigation/move_forward", "parameters": {"distance": 1.0}},\n            "move backward": {"action": "navigation/move_backward", "parameters": {"distance": 1.0}},\n            "turn left": {"action": "navigation/turn", "parameters": {"angle": -90}},\n            "turn right": {"action": "navigation/turn", "parameters": {"angle": 90}},\n            "stop": {"action": "control/stop", "parameters": {}}\n        }\n\n        return simple_map.get(command_text.lower().strip(), {\n            "action": "unknown/command",\n            "parameters": {"text": command_text}\n        })\n'})}),"\n",(0,o.jsx)(e.h3,{id:"2-context-aware-command-mapping",children:"2. Context-Aware Command Mapping"}),"\n",(0,o.jsx)(e.p,{children:"Commands may have different meanings based on context:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'class ContextAwareCommandMapper:\n    def __init__(self):\n        self.context = {}\n        self.command_processors = {\n            "navigation": self._process_navigation_command,\n            "manipulation": self._process_manipulation_command,\n            "system": self._process_system_command\n        }\n\n    def set_context(self, context):\n        """Set current robot context"""\n        self.context = context\n\n    def map_command(self, command_text):\n        """Map command based on current context"""\n        command_lower = command_text.lower().strip()\n\n        # Determine context based on current state or command content\n        context_type = self._determine_context_type(command_lower)\n\n        if context_type in self.command_processors:\n            return self.command_processors[context_type](command_lower)\n        else:\n            return self._default_mapping(command_lower)\n\n    def _determine_context_type(self, command):\n        """Determine the appropriate context for the command"""\n        navigation_keywords = ["move", "turn", "go", "navigate", "forward", "backward", "left", "right"]\n        manipulation_keywords = ["pick", "place", "grab", "take", "drop", "lift", "hold"]\n\n        if any(keyword in command for keyword in navigation_keywords):\n            return "navigation"\n        elif any(keyword in command for keyword in manipulation_keywords):\n            return "manipulation"\n        else:\n            return "system"\n\n    def _process_navigation_command(self, command):\n        """Process navigation-specific commands"""\n        # Navigation-specific logic\n        if "forward" in command or "ahead" in command:\n            distance = self._extract_distance(command) or 1.0\n            return {\n                "action": "navigation/move_forward",\n                "parameters": {"distance": distance}\n            }\n        elif "backward" in command or "back" in command:\n            distance = self._extract_distance(command) or 1.0\n            return {\n                "action": "navigation/move_backward",\n                "parameters": {"distance": distance}\n            }\n        elif "turn left" in command:\n            angle = self._extract_angle(command) or 90\n            return {\n                "action": "navigation/turn",\n                "parameters": {"angle": -angle}\n            }\n        elif "turn right" in command:\n            angle = self._extract_angle(command) or 90\n            return {\n                "action": "navigation/turn",\n                "parameters": {"angle": angle}\n            }\n        else:\n            return {"action": "navigation/unknown", "parameters": {"text": command}}\n\n    def _process_manipulation_command(self, command):\n        """Process manipulation-specific commands"""\n        # Manipulation-specific logic\n        if "pick" in command or "take" in command:\n            object_type = self._extract_object_type(command) or "unknown"\n            return {\n                "action": "manipulation/pick_object",\n                "parameters": {"object_type": object_type}\n            }\n        elif "place" in command or "drop" in command or "put" in command:\n            return {\n                "action": "manipulation/place_object",\n                "parameters": {}\n            }\n        else:\n            return {"action": "manipulation/unknown", "parameters": {"text": command}}\n\n    def _process_system_command(self, command):\n        """Process system-level commands"""\n        return {"action": "system/unknown", "parameters": {"text": command}}\n\n    def _extract_distance(self, command):\n        """Extract distance from command"""\n        match = re.search(r"(\\d+(?:\\.\\d+)?)\\s*(?:meters?|m)", command)\n        if match:\n            return float(match.group(1))\n        return None\n\n    def _extract_angle(self, command):\n        """Extract angle from command"""\n        match = re.search(r"(\\d+(?:\\.\\d+)?)\\s*(?:degrees?|deg)", command)\n        if match:\n            return float(match.group(1))\n        return None\n\n    def _extract_object_type(self, command):\n        """Extract object type from command"""\n        # Simple extraction - in practice, this would be more sophisticated\n        words = command.split()\n        for i, word in enumerate(words):\n            if word in ["the", "a", "an"]:\n                if i + 1 < len(words):\n                    return words[i + 1]\n        return "object"\n\n    def _default_mapping(self, command):\n        """Default command mapping"""\n        return {"action": "unknown/command", "parameters": {"text": command}}\n'})}),"\n",(0,o.jsx)(e.h2,{id:"integration-with-llms-for-complex-mapping",children:"Integration with LLMs for Complex Mapping"}),"\n",(0,o.jsx)(e.p,{children:"For more sophisticated command understanding, integrate with Large Language Models:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'import openai\n\nclass LLMCommandMapper:\n    def __init__(self, api_key):\n        openai.api_key = api_key\n        self.system_prompt = """\n        You are a robot command interpreter. Your job is to convert natural language commands into structured robot actions.\n\n        Available action types:\n        - navigation/move_forward: Move robot forward\n          Parameters: distance (float in meters)\n        - navigation/move_backward: Move robot backward\n          Parameters: distance (float in meters)\n        - navigation/turn: Turn robot\n          Parameters: angle (float in degrees)\n        - manipulation/pick_object: Pick up an object\n          Parameters: object_type (string)\n        - manipulation/place_object: Place an object\n          Parameters: location (string)\n        - control/stop: Stop current action\n          Parameters: none\n        - control/pause: Pause robot\n          Parameters: none\n\n        Respond with a JSON object containing \'action\' and \'parameters\' keys.\n        If the command is unclear or not a robot command, return action \'unknown/command\'.\n        """\n\n    def map_command(self, command_text):\n        """Map command using LLM for complex understanding"""\n        try:\n            response = openai.ChatCompletion.create(\n                model="gpt-3.5-turbo",\n                messages=[\n                    {"role": "system", "content": self.system_prompt},\n                    {"role": "user", "content": f"Command: {command_text}"}\n                ],\n                temperature=0.1,\n                max_tokens=200\n            )\n\n            # Parse the response (in a real implementation, you\'d want more robust JSON parsing)\n            import json\n            response_text = response.choices[0].message.content.strip()\n\n            # Extract JSON from response if wrapped in code blocks\n            if "```json" in response_text:\n                json_start = response_text.find("```json") + 7\n                json_end = response_text.find("```", json_start)\n                json_str = response_text[json_start:json_end].strip()\n            elif "```" in response_text:\n                code_start = response_text.find("```") + 3\n                code_end = response_text.find("```", code_start)\n                json_str = response_text[code_start:code_end].strip()\n            else:\n                json_str = response_text\n\n            return json.loads(json_str)\n\n        except Exception as e:\n            print(f"LLM command mapping failed: {e}")\n            # Fallback to simpler mapping\n            return self._fallback_mapping(command_text)\n\n    def _fallback_mapping(self, command_text):\n        """Simple fallback mapping"""\n        simple_mapper = StaticCommandMapper()\n        return simple_mapper.map_command(command_text)\n'})}),"\n",(0,o.jsx)(e.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,o.jsx)(e.h3,{id:"1-caching-mapped-commands",children:"1. Caching Mapped Commands"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'from functools import lru_cache\nimport hashlib\n\nclass CachedCommandMapper:\n    def __init__(self, base_mapper, cache_size=1000):\n        self.base_mapper = base_mapper\n        self.cache_size = cache_size\n\n    @lru_cache(maxsize=1000)\n    def _cached_map(self, command_hash, command_text):\n        """Cached command mapping"""\n        return self.base_mapper.map_command(command_text)\n\n    def map_command(self, command_text):\n        """Map command with caching"""\n        command_hash = hashlib.md5(command_text.encode()).hexdigest()\n        return self._cached_map(command_hash, command_text)\n'})}),"\n",(0,o.jsx)(e.h3,{id:"2-confidence-scoring",children:"2. Confidence Scoring"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'class ConfidentCommandMapper:\n    def __init__(self):\n        self.fuzzy_mapper = FuzzyCommandMapper()\n\n    def map_command_with_confidence(self, command_text):\n        """Map command with confidence scoring"""\n        # Use fuzzy matching to get confidence\n        command_lower = command_text.lower().strip()\n\n        best_matches = difflib.get_close_matches(\n            command_lower,\n            [cmd for variations in self.fuzzy_mapper.command_variations.values() for cmd in variations],\n            n=1,\n            cutoff=0.3  # Lower cutoff to capture more possibilities\n        )\n\n        if best_matches:\n            confidence = difflib.SequenceMatcher(None, command_lower, best_matches[0]).ratio()\n\n            # Map to canonical command\n            mapped_result = self.fuzzy_mapper.map_command(command_text)\n            mapped_result["confidence"] = confidence\n\n            # Only execute if confidence is above threshold\n            if confidence < 0.7:\n                mapped_result["action"] = "uncertain/command"\n                mapped_result["parameters"]["confidence"] = confidence\n\n            return mapped_result\n        else:\n            return {\n                "action": "unknown/command",\n                "parameters": {"text": command_text, "confidence": 0.0}\n            }\n'})}),"\n",(0,o.jsx)(e.h2,{id:"testing-command-mapping",children:"Testing Command Mapping"}),"\n",(0,o.jsx)(e.h3,{id:"1-unit-tests",children:"1. Unit Tests"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'import unittest\n\nclass TestCommandMapping(unittest.TestCase):\n    def setUp(self):\n        self.mapper = StaticCommandMapper()\n\n    def test_basic_command_mapping(self):\n        """Test basic command mapping"""\n        result = self.mapper.map_command("move forward")\n        self.assertEqual(result["action"], "navigation/move_forward")\n        self.assertEqual(result["parameters"]["distance"], 1.0)\n\n    def test_partial_command_matching(self):\n        """Test partial command matching"""\n        result = self.mapper.map_command("please move forward")\n        self.assertEqual(result["action"], "navigation/move_forward")\n\n    def test_unknown_command(self):\n        """Test unknown command handling"""\n        result = self.mapper.map_command("unknown command")\n        self.assertEqual(result["action"], "unknown/command")\n'})}),"\n",(0,o.jsx)(e.h3,{id:"2-integration-tests",children:"2. Integration Tests"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'def test_complete_mapping_pipeline():\n    """Test the complete voice-to-action mapping pipeline"""\n    # Simulate voice command through the entire pipeline\n    voice_input = "move forward 2 meters"\n\n    # Step 1: Transcription (simulated)\n    transcribed_text = voice_input  # In real implementation, this comes from Whisper\n\n    # Step 2: Command mapping\n    mapper = ParameterizedCommandMapper()\n    mapped_action = mapper.map_command(transcribed_text)\n\n    # Step 3: Verify correct mapping\n    assert mapped_action["action"] == "navigation/move_forward"\n    assert mapped_action["parameters"]["distance"] == 2.0\n\n    print("Pipeline test passed!")\n'})}),"\n",(0,o.jsx)(e.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Start Simple"}),": Begin with static command mapping and add complexity as needed"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Handle Ambiguity"}),": Always have fallback strategies for unclear commands"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Context Awareness"}),": Consider robot state and environment when mapping commands"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"User Feedback"}),": Provide clear feedback when commands are recognized or rejected"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Continuous Learning"}),": Consider implementing systems that learn from user interactions"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Safety First"}),": Ensure mapped commands are safe for robot execution"]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"troubleshooting-common-issues",children:"Troubleshooting Common Issues"}),"\n",(0,o.jsx)(e.h3,{id:"1-command-not-recognized",children:"1. Command Not Recognized"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Check for exact text matches in your command map"}),"\n",(0,o.jsx)(e.li,{children:"Implement fuzzy matching for variations"}),"\n",(0,o.jsx)(e.li,{children:"Verify transcription quality from Whisper"}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"2-incorrect-parameter-extraction",children:"2. Incorrect Parameter Extraction"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Test regex patterns thoroughly"}),"\n",(0,o.jsx)(e.li,{children:"Add validation for extracted parameters"}),"\n",(0,o.jsx)(e.li,{children:"Implement parameter range checking"}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"3-high-false-positives",children:"3. High False Positives"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Increase confidence thresholds"}),"\n",(0,o.jsx)(e.li,{children:"Add more specific command patterns"}),"\n",(0,o.jsx)(e.li,{children:"Implement context validation"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,o.jsx)(e.p,{children:"After implementing basic command mapping, consider:"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsx)(e.li,{children:"Adding support for multi-step commands"}),"\n",(0,o.jsx)(e.li,{children:"Implementing command confirmation for critical actions"}),"\n",(0,o.jsx)(e.li,{children:"Adding undo/cancel functionality"}),"\n",(0,o.jsx)(e.li,{children:"Integrating with robot state monitoring"}),"\n",(0,o.jsx)(e.li,{children:"Adding support for custom user-defined commands"}),"\n"]})]})}function p(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(d,{...n})}):d(n)}}}]);